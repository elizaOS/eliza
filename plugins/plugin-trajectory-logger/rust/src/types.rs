use serde::{Deserialize, Serialize};
/// JSON-compatible value type used throughout the trajectory format.
pub type JsonValue = serde_json::Value;
use std::collections::HashMap;

/// LLM call purpose.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
#[derive(Default)]
pub enum LLMPurpose {
    /// LLM call for action selection or execution.
    Action,
    /// LLM call for reasoning or planning.
    Reasoning,
    /// LLM call for evaluation or scoring.
    Evaluation,
    /// LLM call for generating a response.
    Response,
    /// Other or unspecified purpose.
    #[default]
    Other,
}

/// Conversation message used inside an LLM call.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct LLMMessage {
    /// The role of the message sender (e.g., "user", "assistant", "system").
    pub role: String,
    /// The text content of the message.
    pub content: String,
}

/// Represents a single LLM call.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LLMCall {
    /// Unique identifier for this LLM call.
    pub call_id: String,
    /// Unix timestamp in milliseconds when the call was made.
    pub timestamp: i64,
    /// Name of the model used for this call.
    pub model: String,
    /// Optional version string for the model.
    pub model_version: Option<String>,
    /// System prompt provided to the LLM.
    pub system_prompt: String,
    /// User prompt provided to the LLM.
    pub user_prompt: String,
    /// Optional list of conversation messages for multi-turn calls.
    pub messages: Option<Vec<LLMMessage>>,
    /// The response text generated by the LLM.
    pub response: String,
    /// Optional reasoning or chain-of-thought from the LLM.
    pub reasoning: Option<String>,
    /// Temperature parameter used for sampling.
    pub temperature: f64,
    /// Maximum tokens allowed in the response.
    pub max_tokens: u32,
    /// Optional top-p (nucleus) sampling parameter.
    pub top_p: Option<f64>,
    /// Optional count of tokens in the prompt.
    pub prompt_tokens: Option<u32>,
    /// Optional count of tokens in the completion.
    pub completion_tokens: Option<u32>,
    /// Optional latency of the call in milliseconds.
    pub latency_ms: Option<u32>,
    /// The purpose of this LLM call.
    pub purpose: LLMPurpose,
    /// Optional action type if this call was for action selection.
    pub action_type: Option<String>,
}

/// Provider access record.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ProviderAccess {
    /// Unique identifier for the provider.
    pub provider_id: String,
    /// Human-readable name of the provider.
    pub provider_name: String,
    /// Unix timestamp in milliseconds when the access occurred.
    pub timestamp: i64,
    /// Optional query parameters used to access the provider.
    pub query: Option<HashMap<String, JsonValue>>,
    /// Data returned by the provider.
    pub data: HashMap<String, JsonValue>,
    /// The purpose or reason for accessing this provider.
    pub purpose: String,
}

/// Action attempt record.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ActionAttempt {
    /// Unique identifier for this action attempt.
    pub attempt_id: String,
    /// Unix timestamp in milliseconds when the action was attempted.
    pub timestamp: i64,
    /// The type/category of the action.
    pub action_type: String,
    /// The specific name of the action.
    pub action_name: String,
    /// Parameters passed to the action.
    pub parameters: HashMap<String, JsonValue>,
    /// Optional reasoning behind choosing this action.
    pub reasoning: Option<String>,
    /// Optional reference to the LLM call that generated this action.
    pub llm_call_id: Option<String>,
    /// Whether the action executed successfully.
    pub success: bool,
    /// Optional result data from the action execution.
    pub result: Option<HashMap<String, JsonValue>>,
    /// Optional error message if the action failed.
    pub error: Option<String>,
    /// Optional immediate reward signal from this action.
    pub immediate_reward: Option<f64>,
}

/// Environment state snapshot.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct EnvironmentState {
    /// Unix timestamp in milliseconds for this state snapshot.
    pub timestamp: i64,
    /// Current balance of the agent.
    pub agent_balance: f64,
    /// Current points accumulated by the agent.
    pub agent_points: f64,
    /// Current profit and loss of the agent.
    pub agent_pnl: f64,
    /// Number of open positions held by the agent.
    pub open_positions: u32,
    /// Optional count of active markets the agent is tracking.
    pub active_markets: Option<u32>,
    /// Optional total portfolio value.
    pub portfolio_value: Option<f64>,
    /// Optional count of unread messages.
    pub unread_messages: Option<u32>,
    /// Optional recent engagement metric.
    pub recent_engagement: Option<u32>,
    /// Optional custom state data as key-value pairs.
    pub custom: Option<HashMap<String, JsonValue>>,
}

/// Trajectory step.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct TrajectoryStep {
    /// Unique identifier for this step.
    pub step_id: String,
    /// Sequential step number within the trajectory (0-indexed).
    pub step_number: u32,
    /// Unix timestamp in milliseconds when this step occurred.
    pub timestamp: i64,
    /// Environment state at the beginning of this step.
    pub environment_state: EnvironmentState,
    /// Observations available to the agent at this step.
    #[serde(default)]
    pub observation: HashMap<String, JsonValue>,
    /// LLM calls made during this step.
    #[serde(default)]
    pub llm_calls: Vec<LLMCall>,
    /// Provider accesses made during this step.
    #[serde(default)]
    pub provider_accesses: Vec<ProviderAccess>,
    /// Optional reasoning for the action taken in this step.
    pub reasoning: Option<String>,
    /// The action attempted in this step.
    pub action: ActionAttempt,
    /// Reward received for this step.
    pub reward: f64,
    /// Whether this step terminates the trajectory.
    pub done: bool,
    /// Optional additional metadata for this step.
    pub metadata: Option<HashMap<String, JsonValue>>,
}

/// Reward component breakdown (free-form).
pub type RewardBreakdown = HashMap<String, f64>;

/// Reward components.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct RewardComponents {
    /// Reward from the environment/simulator.
    pub environment_reward: f64,
    /// Optional reward from an AI judge evaluation.
    pub ai_judge_reward: Option<f64>,
    /// Optional breakdown of reward into named components.
    pub components: Option<RewardBreakdown>,
    /// Optional model used for AI judge evaluation.
    pub judge_model: Option<String>,
    /// Optional reasoning from the AI judge.
    pub judge_reasoning: Option<String>,
    /// Optional timestamp when the judge evaluation occurred.
    pub judge_timestamp: Option<i64>,
}

/// Trajectory final status.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
#[derive(Default)]
pub enum FinalStatus {
    /// Trajectory completed successfully.
    #[default]
    Completed,
    /// Trajectory was terminated early (e.g., by user or system).
    Terminated,
    /// Trajectory ended due to an error.
    Error,
    /// Trajectory ended due to a timeout.
    Timeout,
}

/// Trajectory metrics (includes an `extra` map for arbitrary metrics).
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct TrajectoryMetrics {
    /// Number of steps in the trajectory.
    pub episode_length: u32,
    /// Final status of the trajectory.
    pub final_status: FinalStatus,
    /// Optional final balance at trajectory end.
    pub final_balance: Option<f64>,
    /// Optional final profit and loss at trajectory end.
    pub final_pnl: Option<f64>,
    /// Optional count of trades executed during the trajectory.
    pub trades_executed: Option<u32>,
    /// Optional count of posts created during the trajectory.
    pub posts_created: Option<u32>,
    /// Optional count of messages handled during the trajectory.
    pub messages_handled: Option<u32>,
    /// Optional success rate (0.0 to 1.0) for actions in the trajectory.
    pub success_rate: Option<f64>,
    /// Optional count of errors encountered during the trajectory.
    pub error_count: Option<u32>,
    /// Additional custom metrics as key-value pairs.
    #[serde(flatten)]
    pub extra: HashMap<String, JsonValue>,
}

/// Trajectory record.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct Trajectory {
    /// Unique identifier for this trajectory.
    pub trajectory_id: String,
    /// Identifier of the agent that generated this trajectory.
    pub agent_id: String,
    /// Unix timestamp in milliseconds when the trajectory started.
    pub start_time: i64,
    /// Unix timestamp in milliseconds when the trajectory ended.
    pub end_time: i64,
    /// Total duration of the trajectory in milliseconds.
    pub duration_ms: i64,
    /// Optional episode identifier within a scenario.
    pub episode_id: Option<String>,
    /// Optional scenario identifier for grouping related trajectories.
    pub scenario_id: Option<String>,
    /// Optional batch identifier for bulk processing.
    pub batch_id: Option<String>,
    /// Optional index within a trajectory group.
    pub group_index: Option<u32>,
    /// List of steps in the trajectory.
    #[serde(default)]
    pub steps: Vec<TrajectoryStep>,
    /// Total cumulative reward for the trajectory.
    pub total_reward: f64,
    /// Breakdown of reward components.
    pub reward_components: RewardComponents,
    /// Summary metrics for the trajectory.
    pub metrics: TrajectoryMetrics,
    /// Additional metadata as key-value pairs.
    #[serde(default)]
    pub metadata: HashMap<String, JsonValue>,
}

/// Chat message for ART format.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ChatMessage {
    /// The role of the message sender (e.g., "user", "assistant", "system").
    pub role: String,
    /// The text content of the message.
    pub content: String,
    /// Optional name of the sender for multi-participant conversations.
    pub name: Option<String>,
}

/// ART trajectory format (messages + reward + metadata).
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ARTTrajectory {
    /// List of chat messages in the trajectory.
    pub messages: Vec<ChatMessage>,
    /// Total reward for the trajectory.
    pub reward: f64,
    /// Additional metadata as key-value pairs.
    pub metadata: HashMap<String, JsonValue>,
    /// Optional numeric metrics for the trajectory.
    pub metrics: Option<HashMap<String, f64>>,
}

/// Trajectory group (for GRPO).
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct TrajectoryGroup {
    /// Unique identifier for this trajectory group.
    pub group_id: String,
    /// Scenario identifier shared by all trajectories in the group.
    pub scenario_id: String,
    /// List of trajectories in this group.
    pub trajectories: Vec<Trajectory>,
    /// Optional shared message prefix common to all trajectories.
    pub shared_prefix: Option<Vec<ChatMessage>>,
    /// Optional rankings of trajectories (1 = best).
    pub rankings: Option<Vec<i32>>,
    /// Optional normalized rewards (0.0 to 1.0) for each trajectory.
    pub normalized_rewards: Option<Vec<f64>>,
    /// Optional ruler scores for preference learning.
    pub ruler_scores: Option<Vec<f64>>,
    /// Unix timestamp in milliseconds when the group was created.
    pub created_at: i64,
    /// Optional model version that generated these trajectories.
    pub model_version: Option<String>,
}
