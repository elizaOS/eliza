import { text, integer, sqliteTable, primaryKey } from 'drizzle-orm/sqlite-core';
import { relations } from 'drizzle-orm';
import { DelegatedSubTaskStatus } from '../../../../plugin-a2a-communication/src/types'; // Adjust path as needed

// Using a relative path to access types from plugin-a2a-communication.
// This assumes a specific monorepo structure.
// In a real scenario, these enums/types might be in @elizaos/core or a shared types package.
// For now, this relative import will be problematic if this plugin is published independently.
// We'll proceed with this for PoC, but this dependency needs careful consideration.
// A better way would be to redefine or import from a shared location if possible.

// Re-define enum here if direct import is an issue for a separate package,
// or ensure types are exported from a common place.
// For this PoC, let's assume the import works or we redefine it.
// If not, I'll redefine it locally.
// Let's try redefining for cleaner separation for this utility package:
export enum SupervisorTaskStatus {
  PENDING_DELEGATION = 'PENDING_DELEGATION',
  DELEGATION_SENT = 'DELEGATION_SENT',
  ACKNOWLEDGED = 'ACKNOWLEDGED',
  IN_PROGRESS = 'IN_PROGRESS',
  SUCCESS = 'SUCCESS',
  FAILURE = 'FAILURE',
  WAITING_FOR_DEPENDENCY = 'WAITING_FOR_DEPENDENCY',
}


export const delegatedSubTasksTable = sqliteTable('delegated_sub_tasks', {
  // Internal unique ID for this database record.
  id: text('id').primaryKey().$defaultFn(() => crypto.randomUUID()), // Using crypto.randomUUID for modern Node

  // ID of the overall project or conversation this sub-task belongs to.
  // Helps group all sub-tasks related to a single high-level goal managed by the supervisor.
  projectConversationId: text('project_conversation_id').notNull(),

  // The message_id of the A2A TASK_REQUEST message that was sent to the specialist agent for this sub-task.
  // This is crucial for linking A2A ACKs and TASK_RESPONSEs back to this DB record.
  a2aRequestMessageId: text('a2a_request_message_id').notNull().unique(),

  // A human-readable name for the sub-task, often generated by the supervisor's LLM during decomposition.
  subTaskName: text('sub_task_name').notNull(),

  // The agent_id of the specialist agent to whom this sub-task was assigned.
  assignedAgentId: text('assigned_agent_id').notNull(),

  // Current status of this sub-task. Uses the SupervisorTaskStatus enum.
  status: text('status', { enum: Object.values(SupervisorTaskStatus) as [string, ...string[]] }).notNull().default(SupervisorTaskStatus.PENDING_DELEGATION),

  // Stores a summary of the result if the task is successful, or relevant details.
  // Could be stringified JSON or plain text. Limited length for DB efficiency.
  resultSummary: text('result_summary'),

  // Stores error message details if the task status is FAILURE.
  lastErrorMessage: text('last_error_message'),

  // JSON string representing the parameters sent to the specialist agent for this sub-task.
  // Useful for retries, debugging, or if the supervisor needs to re-evaluate.
  parametersJson: text('parameters_json'), // Store as JSON string

  // JSON string array of subTaskName(s) that this task depends on.
  // Example: '["CREATE_API_SPEC", "SETUP_DATABASE"]'
  dependenciesJson: text('dependencies_json'), // Store as JSON string

  // Timestamp when the supervisor decided to delegate this task (or recorded it).
  delegatedAt: text('delegated_at').notNull().$defaultFn(() => new Date().toISOString()),

  // Timestamp of the last status update for this task.
  lastStatusUpdateAt: text('last_status_update_at').notNull().$defaultFn(() => new Date().toISOString()),
});

// TypeScript types inferred from the schema
export type DelegatedSubTask = typeof delegatedSubTasksTable.$inferSelect;
export type NewDelegatedSubTask = typeof delegatedSubTasksTable.$inferInsert;

// Example of how relations might be defined if there was a "projects" table
// export const projectRelations = relations(delegatedSubTasksTable, ({ one }) => ({
//   project: one(projectsTable, { // Assuming a 'projectsTable' exists
//     fields: [delegatedSubTasksTable.projectConversationId],
//     references: [projectsTable.id],
//   }),
// }));

// Note: This schema is defined using SQLite syntax via drizzle-orm/sqlite-core.
// If @elizaos/plugin-sql uses PostgreSQL, the syntax (especially for enums and default UUIDs)
// would need to be adjusted (e.g., using `pgTable`, `varchar`, `uuid().defaultRandom()`, `timestamp()`).
// For this PoC, SQLite provides a simple, file-based way to conceptualize the DB structure.
// The actual DB interaction will be mocked in tests for `SupervisorTaskDBService`.
// Migrations would be handled by `drizzle-kit` typically.
// The $defaultFn for timestamps assumes they are set at application level during insert.
// DB-level defaults (e.g., CURRENT_TIMESTAMP) are also an option.
// Using crypto.randomUUID() for 'id' requires Node.js 19+ or a polyfill.
// If targeting older Node, consider `uuid` package for `id` default.
// For enum, Drizzle ORM typically creates a TEXT column with a CHECK constraint for SQLite.
// For PostgreSQL, it would use a native ENUM type.
// The `text('status', { enum: [...] })` is the correct way for Drizzle to handle this for various drivers.
// The `as [string, ...string[]]` cast is for TypeScript to accept the array from Object.values().
