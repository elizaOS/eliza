//! Message service for elizaOS
//!
//! This module provides the message handling service that processes incoming messages
//! and generates responses using the agent's character, providers, and model handlers.

use crate::runtime::AgentRuntime;
use crate::types::{Content, Memory, State, UUID};
use anyhow::Result;
use async_trait::async_trait;
use std::sync::Arc;
use tracing::{debug, error, info};

/// Callback for handling response content
pub type HandlerCallback = Arc<dyn Fn(Content) -> Result<Vec<Memory>> + Send + Sync>;

/// Options for message processing
#[derive(Default, Clone)]
pub struct MessageProcessingOptions {
    /// Maximum number of retries for LLM calls if required fields are missing
    pub max_retries: Option<u32>,
    /// Timeout for message processing in milliseconds
    pub timeout_duration: Option<u64>,
}

/// Result of message processing
#[derive(Debug, Clone)]
pub struct MessageProcessingResult {
    /// Whether the agent decided to respond
    pub did_respond: bool,
    /// The response content generated by the agent
    pub response_content: Option<Content>,
    /// Response messages generated
    pub response_messages: Vec<Memory>,
    /// Final state after processing
    pub state: State,
}

impl Default for MessageProcessingResult {
    fn default() -> Self {
        Self {
            did_respond: false,
            response_content: None,
            response_messages: Vec::new(),
            state: State::new(),
        }
    }
}

/// Interface for message handling service
#[cfg_attr(not(feature = "wasm"), async_trait)]
#[cfg_attr(feature = "wasm", async_trait(?Send))]
pub trait IMessageService: Send + Sync {
    /// Process an incoming message and generate a response
    async fn handle_message(
        &self,
        runtime: &AgentRuntime,
        message: &mut Memory,
        callback: Option<HandlerCallback>,
        options: Option<MessageProcessingOptions>,
    ) -> Result<MessageProcessingResult>;
}

/// Default implementation of the message service
pub struct DefaultMessageService;

impl DefaultMessageService {
    /// Create a new DefaultMessageService
    pub fn new() -> Self {
        Self
    }
}

impl Default for DefaultMessageService {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg_attr(not(feature = "wasm"), async_trait)]
#[cfg_attr(feature = "wasm", async_trait(?Send))]
impl IMessageService for DefaultMessageService {
    async fn handle_message(
        &self,
        runtime: &AgentRuntime,
        message: &mut Memory,
        callback: Option<HandlerCallback>,
        _options: Option<MessageProcessingOptions>,
    ) -> Result<MessageProcessingResult> {
        // Start run tracking
        let _run_id = runtime.start_run(Some(&message.room_id));
        let start_time = std::time::Instant::now();

        debug!(
            "Processing message from entity {:?} in room {:?}",
            message.entity_id, message.room_id
        );

        // Check if shouldRespond evaluation is enabled
        // When disabled (ChatGPT mode), we always respond
        let check_should_respond = runtime.is_check_should_respond_enabled().await;
        if !check_should_respond {
            debug!("check_should_respond disabled, always responding (ChatGPT mode)");
        }
        // Note: This implementation always responds, so check_should_respond=false
        // maintains the default behavior. When shouldRespond logic is added,
        // this check will bypass it when check_should_respond is false.

        // Save the incoming message to memory first
        if let Some(adapter) = runtime.get_adapter() {
            debug!("Saving incoming message to memory");

            // Generate ID if not present
            if message.id.is_none() {
                message.id = Some(UUID::new_v4());
            }

            // Check if memory already exists
            let message_id = message.id.as_ref().unwrap();
            let existing = adapter.get_memory_by_id(message_id).await?;
            if existing.is_none() {
                adapter.create_memory(message, "messages").await?;
                debug!("Saved incoming message with ID {:?}", message_id);
            } else {
                debug!("Message already exists in memory, skipping save");
            }
        }

        // Compose state from providers
        let state = runtime.compose_state(message).await?;

        // Build the prompt
        let prompt = build_prompt(runtime, message, &state);

        // Get system prompt from character
        let system_prompt = {
            #[cfg(not(feature = "wasm"))]
            {
                runtime.character.read().await.system.clone()
            }
            #[cfg(feature = "wasm")]
            {
                runtime.character.read().unwrap().system.clone()
            }
        };

        // Generate response using the model (calls registered model handler)
        let response_text = runtime.use_model(
            "TEXT_LARGE",
            serde_json::json!({
                "prompt": prompt,
                "system": system_prompt,
                "temperature": 0.7
            }),
        ).await?;

        // Create response content
        let response_content = Content {
            text: Some(response_text.clone()),
            ..Default::default()
        };

        // Create response memory
        let response_id = UUID::new_v4();
        let response_memory = Memory {
            id: Some(response_id.clone()),
            entity_id: runtime.agent_id.clone(),
            agent_id: Some(runtime.agent_id.clone()),
            room_id: message.room_id.clone(),
            content: response_content.clone(),
            created_at: Some(chrono_timestamp()),
            embedding: None,
            world_id: None,
            unique: Some(true),
            similarity: None,
            metadata: None,
        };

        // Save response memory
        if let Some(adapter) = runtime.get_adapter() {
            debug!("Saving response to memory");
            adapter.create_memory(&response_memory, "messages").await?;
            debug!("Saved response with ID {:?}", response_id);
        }

        // Call the callback if provided
        if let Some(cb) = callback {
            if let Err(e) = cb(response_content.clone()) {
                error!("Callback error: {:?}", e);
            }
        }

        let elapsed = start_time.elapsed();
        info!("Message processing completed in {:?}", elapsed);

        runtime.end_run();

        Ok(MessageProcessingResult {
            did_respond: true,
            response_content: Some(response_content),
            response_messages: vec![response_memory],
            state,
        })
    }
}

/// Build the prompt for the model
fn build_prompt(runtime: &AgentRuntime, message: &Memory, state: &State) -> String {
    let character_name = {
        #[cfg(not(feature = "wasm"))]
        {
            futures::executor::block_on(async {
                runtime.character.read().await.name.clone()
            })
        }
        #[cfg(feature = "wasm")]
        {
            runtime.character.read().unwrap().name.clone()
        }
    };

    let user_text = message.content.text.as_deref().unwrap_or("");

    // Include state text from providers if available
    let context = if state.text.is_empty() {
        String::new()
    } else {
        state.text.clone()
    };

    let mut prompt_parts = Vec::new();

    if !context.is_empty() {
        prompt_parts.push(context);
    }

    prompt_parts.push(format!("User: {}", user_text));
    prompt_parts.push(format!("{}:", character_name));

    prompt_parts.join("\n")
}

/// Get current timestamp in milliseconds
fn chrono_timestamp() -> i64 {
    std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap()
        .as_millis() as i64
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_message_processing_result_default() {
        let result = MessageProcessingResult::default();
        assert!(!result.did_respond);
        assert!(result.response_content.is_none());
        assert!(result.response_messages.is_empty());
    }

    #[test]
    fn test_message_processing_options_default() {
        let options = MessageProcessingOptions::default();
        assert!(options.max_retries.is_none());
        assert!(options.timeout_duration.is_none());
    }
}

