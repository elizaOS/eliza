/**
 * GitHub Integration Service for ElizaOS Autocoder
 * Handles repository creation, code storage, and collaboration features
 */

import { Octokit } from '@octokit/rest';

export interface GitHubConfig {
  token: string;
  org?: string;
  defaultBranch?: string;
}

export interface ProjectMetadata {
  projectId: string;
  name: string;
  description: string;
  type: string;
  tags: string[];
  userId: string;
  userName?: string;
}

export interface GeneratedFiles {
  [path: string]: string;
}

export interface RepositoryMatch {
  name: string;
  description: string;
  url: string;
  stars: number;
  topics: string[];
  language: string;
  relevanceScore: number;
}

export interface FileChanges {
  path: string;
  content: string;
  encoding?: 'utf-8' | 'base64';
}

export class GitHubIntegrationService {
  private octokit: Octokit;
  private config: GitHubConfig;

  constructor(config: GitHubConfig) {
    this.config = config;
    this.octokit = new Octokit({
      auth: config.token,
    });
  }

  /**
   * Create a private repository for the project
   */
  async createPrivateRepo(metadata: ProjectMetadata): Promise<string> {
    try {
      const repoName = this.generateRepoName(metadata);

      // Check if repository already exists
      const existingRepo = await this.checkRepoExists(repoName);
      if (existingRepo) {
        console.log(`Repository ${repoName} already exists, returning existing URL`);
        return existingRepo.html_url;
      }

      const response = await this.octokit.repos.createForAuthenticatedUser({
        name: repoName,
        description: `${metadata.description} - Generated by ElizaOS Autocoder`,
        private: true,
        auto_init: true,
        gitignore_template: 'Node',
        license_template: 'mit',
        topics: [
          'elizaos',
          'autocoder',
          metadata.type,
          'ai-generated',
          ...metadata.tags,
        ],
      });

      console.log(`Created repository: ${response.data.html_url}`);
      return response.data.html_url;
    } catch (error) {
      console.error('Failed to create GitHub repository:', error);
      throw new Error(`GitHub repository creation failed: ${error}`);
    }
  }

  /**
   * Search for similar repositories based on requirements
   */
  async searchSimilarRepos(requirements: string[]): Promise<RepositoryMatch[]> {
    try {
      const searchQueries = this.buildSearchQueries(requirements);
      const allResults: RepositoryMatch[] = [];

      for (const query of searchQueries) {
        const response = await this.octokit.search.repos({
          q: query,
          sort: 'stars',
          order: 'desc',
          per_page: 20,
        });

        const matches = response.data.items.map(repo => ({
          name: repo.full_name,
          description: repo.description || '',
          url: repo.html_url,
          stars: repo.stargazers_count,
          topics: repo.topics || [],
          language: repo.language || 'Unknown',
          relevanceScore: this.calculateRelevanceScore(repo, requirements),
        }));

        allResults.push(...matches);
      }

      // Deduplicate and sort by relevance
      const uniqueResults = this.deduplicateResults(allResults);
      return uniqueResults
        .sort((a, b) => b.relevanceScore - a.relevanceScore)
        .slice(0, 10);
    } catch (error) {
      console.error('Failed to search GitHub repositories:', error);
      return [];
    }
  }

  /**
   * Store project results in the repository
   */
  async storeProjectResults(
    repoName: string,
    files: GeneratedFiles,
    metadata: ProjectMetadata
  ): Promise<void> {
    try {
      // Create development branch
      const devBranch = 'development';
      await this.createBranch(repoName, devBranch);

      // Commit all files to the development branch
      const changes: FileChanges[] = Object.entries(files).map(([path, content]) => ({
        path,
        content,
      }));

      await this.commitChanges(
        repoName,
        changes,
        `feat: Initial implementation of ${metadata.name}

Generated by ElizaOS Autocoder
Project Type: ${metadata.type}
Features: ${metadata.tags.join(', ')}

This is a production-ready implementation with:
- Complete functionality
- Comprehensive test suite
- Security best practices
- Documentation`,
        devBranch
      );

      // Create README with project details
      await this.createProjectReadme(repoName, metadata, devBranch);

      // Create pull request
      await this.createPullRequest(
        repoName,
        `üöÄ ${metadata.name} - AI Generated Implementation`,
        `This pull request contains the complete implementation of **${metadata.name}** generated by ElizaOS Autocoder.

## üìã Project Details
- **Type**: ${metadata.type}
- **Description**: ${metadata.description}
- **Generated for**: ${metadata.userName || metadata.userId}

## üéØ Features
${metadata.tags.map(tag => `- ${tag}`).join('\n')}

## üß™ Testing
The implementation includes comprehensive tests. Run with:
\`\`\`bash
npm test
\`\`\`

## üöÄ Deployment
Follow the deployment guide in the README for production setup.

---
*Generated with ‚ù§Ô∏è by ElizaOS Autocoder*`,
        devBranch,
        this.config.defaultBranch || 'main'
      );

      console.log(`Stored project results in repository: ${repoName}`);
    } catch (error) {
      console.error('Failed to store project results:', error);
      throw new Error(`Failed to store results: ${error}`);
    }
  }

  /**
   * Create a new branch from the default branch
   */
  async createBranch(repoName: string, branchName: string): Promise<void> {
    try {
      // Get the default branch SHA
      const { data: defaultBranch } = await this.octokit.repos.getBranch({
        owner: this.getOwner(),
        repo: repoName,
        branch: this.config.defaultBranch || 'main',
      });

      // Create new branch
      await this.octokit.git.createRef({
        owner: this.getOwner(),
        repo: repoName,
        ref: `refs/heads/${branchName}`,
        sha: defaultBranch.commit.sha,
      });

      console.log(`Created branch: ${branchName}`);
    } catch (error: any) {
      if (error.status === 422) {
        // Branch already exists
        console.log(`Branch ${branchName} already exists`);
        return;
      }
      throw error;
    }
  }

  /**
   * Commit changes to a repository
   */
  async commitChanges(
    repoName: string,
    changes: FileChanges[],
    commitMessage: string,
    branch: string = this.config.defaultBranch || 'main'
  ): Promise<string> {
    try {
      const owner = this.getOwner();

      // Get the current commit SHA
      const { data: currentBranch } = await this.octokit.repos.getBranch({
        owner,
        repo: repoName,
        branch,
      });

      // Create blobs for all files
      const blobs = await Promise.all(
        changes.map(async (change) => {
          const { data: blob } = await this.octokit.git.createBlob({
            owner,
            repo: repoName,
            content: change.content,
            encoding: change.encoding || 'utf-8',
          });
          return {
            path: change.path,
            mode: '100644' as const,
            type: 'blob' as const,
            sha: blob.sha,
          };
        })
      );

      // Create tree
      const { data: tree } = await this.octokit.git.createTree({
        owner,
        repo: repoName,
        base_tree: currentBranch.commit.commit.tree.sha,
        tree: blobs,
      });

      // Create commit
      const { data: commit } = await this.octokit.git.createCommit({
        owner,
        repo: repoName,
        message: commitMessage,
        tree: tree.sha,
        parents: [currentBranch.commit.sha],
      });

      // Update branch reference
      await this.octokit.git.updateRef({
        owner,
        repo: repoName,
        ref: `heads/${branch}`,
        sha: commit.sha,
      });

      console.log(`Committed changes to ${branch}: ${commit.sha}`);
      return commit.sha;
    } catch (error) {
      console.error('Failed to commit changes:', error);
      throw error;
    }
  }

  /**
   * Create a pull request
   */
  async createPullRequest(
    repoName: string,
    title: string,
    description: string,
    headBranch: string,
    baseBranch: string
  ): Promise<void> {
    try {
      const { data: pr } = await this.octokit.pulls.create({
        owner: this.getOwner(),
        repo: repoName,
        title,
        body: description,
        head: headBranch,
        base: baseBranch,
      });

      console.log(`Created pull request: ${pr.html_url}`);
    } catch (error) {
      console.error('Failed to create pull request:', error);
      throw error;
    }
  }

  /**
   * Generate a repository name based on project metadata
   */
  private generateRepoName(metadata: ProjectMetadata): string {
    const sanitized = metadata.name
      .toLowerCase()
      .replace(/[^a-z0-9-]/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');

    return `${sanitized}-${Date.now()}`;
  }

  /**
   * Check if a repository already exists
   */
  private async checkRepoExists(repoName: string) {
    try {
      const response = await this.octokit.repos.get({
        owner: this.getOwner(),
        repo: repoName,
      });
      return response.data;
    } catch (error: any) {
      if (error.status === 404) {
        return null;
      }
      throw error;
    }
  }

  /**
   * Build search queries for similar repositories
   */
  private buildSearchQueries(requirements: string[]): string[] {
    const queries = [];

    // Primary search with multiple requirements
    if (requirements.length > 1) {
      queries.push(
        `${requirements.slice(0, 3).join(' ')} language:TypeScript OR language:JavaScript`
      );
    }

    // Individual requirement searches
    requirements.forEach(req => {
      queries.push(`${req} stars:>10 language:TypeScript`);
    });

    // DeFi specific searches
    if (requirements.some(r => r.toLowerCase().includes('defi'))) {
      queries.push('defi ethereum solidity smart-contract stars:>50');
    }

    return queries.slice(0, 5); // Limit to avoid rate limiting
  }

  /**
   * Calculate relevance score for a repository
   */
  private calculateRelevanceScore(repo: any, requirements: string[]): number {
    let score = 0;

    // Base score from stars (normalized)
    score += Math.min(repo.stargazers_count / 100, 10);

    // Description matches
    const description = (repo.description || '').toLowerCase();
    requirements.forEach(req => {
      if (description.includes(req.toLowerCase())) {
        score += 5;
      }
    });

    // Topic matches
    repo.topics?.forEach((topic: string) => {
      requirements.forEach(req => {
        if (topic.toLowerCase().includes(req.toLowerCase())) {
          score += 3;
        }
      });
    });

    // Language preference
    if (repo.language === 'TypeScript') {score += 2;}
    if (repo.language === 'JavaScript') {score += 1;}

    return score;
  }

  /**
   * Remove duplicate results based on repository name
   */
  private deduplicateResults(results: RepositoryMatch[]): RepositoryMatch[] {
    const seen = new Set<string>();
    return results.filter(result => {
      if (seen.has(result.name)) {
        return false;
      }
      seen.add(result.name);
      return true;
    });
  }

  /**
   * Create a comprehensive README for the project
   */
  private async createProjectReadme(
    repoName: string,
    metadata: ProjectMetadata,
    branch: string
  ): Promise<void> {
    const readme = `# ${metadata.name}

${metadata.description}

*Generated by [ElizaOS Autocoder](https://github.com/elizaOS/eliza) - AI-Powered Development*

## üöÄ Quick Start

\`\`\`bash
# Install dependencies
npm install

# Run tests
npm test

# Build the project
npm run build

# Start development server
npm run dev
\`\`\`

## üìã Project Details

- **Type**: ${metadata.type}
- **Generated**: ${new Date().toISOString()}
- **Tags**: ${metadata.tags.join(', ')}

## üõ°Ô∏è Security

This project follows security best practices:
- Input validation and sanitization
- Error handling and logging
- Secure dependency management
- Comprehensive test coverage

## üìö Documentation

Complete documentation is available in the \`docs/\` directory.

## ü§ù Contributing

This project was generated by AI but you can extend and improve it:

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests for new functionality
5. Submit a pull request

## üìÑ License

MIT License - see LICENSE file for details.

---

**Built with ElizaOS Autocoder** - The future of AI-powered development.
`;

    await this.commitChanges(
      repoName,
      [{ path: 'README.md', content: readme }],
      'docs: Add comprehensive README',
      branch
    );
  }

  /**
   * Get the repository owner (user or organization)
   */
  private getOwner(): string {
    return this.config.org || 'self'; // Will need to be resolved to actual username
  }
}

/**
 * Factory function to create GitHub integration service
 */
export function createGitHubIntegration(token: string, org?: string): GitHubIntegrationService {
  return new GitHubIntegrationService({
    token,
    org,
    defaultBranch: 'main',
  });
}
