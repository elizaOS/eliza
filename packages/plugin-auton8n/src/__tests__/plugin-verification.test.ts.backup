import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
import { PluginCreationService, ClaudeModel } from '../services/plugin-creation-service.ts';
import { IAgentRuntime, Plugin, Action, Provider, Memory } from '@elizaos/core';
import fs from 'fs-extra';
import path from 'path';
import { spawn } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(spawn);

describe('Plugin Verification Tests', () => {
  let service: PluginCreationService;
  let runtime: IAgentRuntime;
  let testPluginPath: string;

  beforeEach(async () => {
    runtime = {
      getSetting: vi.fn().mockImplementation((key: string) => {
        if (key === 'PLUGIN_DATA_DIR') return path.join(process.cwd(), 'test-data');
        if (key === 'ANTHROPIC_API_KEY') return process.env.ANTHROPIC_API_KEY || undefined;
        return process.env[key] || null;
      }),
      services: new Map(),
      agentId: 'test-agent-id',
    } as any;

    service = new PluginCreationService(runtime);
    await service.initialize(runtime);

    // Set up a default mock anthropic client
    (service as any).anthropic = {
      messages: { create: vi.fn() },
    };
  });

  afterEach(async () => {
    // Clean up
    if (testPluginPath && (await fs.pathExists(testPluginPath))) {
      await fs.remove(testPluginPath);
    }
  });

  it('should create and execute a working time plugin', async () => {
    const apiKey = process.env.ANTHROPIC_API_KEY;

    if (!apiKey) {
      console.log('⚠️  Skipping: ANTHROPIC_API_KEY not set');
      return;
    }

    // Mock a complete, working plugin response
    const mockAnthropicCreate = vi.fn();

    // First call - initial generation
    mockAnthropicCreate.mockResolvedValueOnce({
      content: [
        {
          type: 'text',
          text: `\`\`\`typescript
// file: src/index.ts
import { Plugin } from '@elizaos/core';
import { getCurrentTimeAction } from './actions/getCurrentTime.js';
import { timeProvider } from './providers/timeProvider.js';

export const timePlugin: Plugin = {
  name: '@elizaos/plugin-time-test',
  description: 'Test time plugin',
  actions: [getCurrentTimeAction],
  providers: [timeProvider],
};

export default timePlugin;
\`\`\`

\`\`\`typescript
// file: src/actions/getCurrentTime.ts
import { Action, IAgentRuntime, Memory, State, HandlerCallback, Content } from '@elizaos/core';

export const getCurrentTimeAction: Action = {
  name: 'GET_CURRENT_TIME',
  description: 'Get current time',
  
  validate: async (runtime: IAgentRuntime, message: Memory, state: State): Promise<boolean> => {
    return true;
  },
  
  handler: async (
    runtime: IAgentRuntime,
    message: Memory,
    state: State,
    options: any,
    callback: HandlerCallback
  ): Promise<any> => {
    const content: Content = {
      text: 'Current time: ' + new Date().toISOString(),
      success: true
    };
    
    if (callback) {
      await callback(content);
    }
    
    return content;
  },
  
  examples: []
};
\`\`\`

\`\`\`typescript
// file: src/providers/timeProvider.ts  
import { Provider, IAgentRuntime, Memory, State } from '@elizaos/core';

export const timeProvider: Provider = {
  name: 'TIME_PROVIDER',
  description: 'Provides time context',
  
  get: async (runtime: IAgentRuntime, message: Memory, state: State) => {
    return {
      text: 'Current timestamp: ' + Date.now(),
      data: {
        timestamp: Date.now()
      }
    };
  }
};
\`\`\`

\`\`\`json
// file: tsup.config.ts
import { defineConfig } from 'tsup';

export default defineConfig({
  entry: ['src/index.ts'],
  format: ['esm'],
  dts: true,
  clean: true,
  target: 'node18',
  outDir: 'dist'
});
\`\`\``,
        },
      ],
    });

    // Update the mock function
    (service as any).anthropic.messages.create = mockAnthropicCreate;

    // Create the plugin
    const spec = {
      name: '@elizaos/plugin-time-test',
      description: 'Test time plugin for verification',
      actions: [
        {
          name: 'getCurrentTime',
          description: 'Get current time',
        },
      ],
      providers: [
        {
          name: 'timeProvider',
          description: 'Time context provider',
        },
      ],
    };

    // Pass a dummy API key to satisfy the validation
    const jobId = await service.createPlugin(spec, undefined, { useTemplate: false });

    // Wait for completion
    let job = service.getJobStatus(jobId);
    let attempts = 0;
    while (job && job.status === 'running' && attempts < 60) {
      await new Promise((resolve) => setTimeout(resolve, 1000));
      job = service.getJobStatus(jobId);
      attempts++;
    }

    expect(job).toBeDefined();
    expect(job!.status).toBe('completed');

    testPluginPath = job!.outputPath;

    // Verify the plugin can be built and loaded
    try {
      // Build the plugin
      console.log('Building generated plugin...');
      const buildProcess = spawn('npm', ['run', 'build'], {
        cwd: testPluginPath,
        shell: true,
      });

      await new Promise((resolve, reject) => {
        buildProcess.on('close', (code) => {
          if (code === 0) resolve(undefined);
          else reject(new Error(`Build failed with code ${code}`));
        });
        buildProcess.on('error', reject);
      });

      // Check if dist files were created
      const distPath = path.join(testPluginPath, 'dist/index.js');
      expect(await fs.pathExists(distPath)).toBe(true);

      // Load the plugin dynamically
      console.log('Loading generated plugin...');
      const pluginModule = await import(distPath);
      const plugin: Plugin = pluginModule.default || pluginModule.timePlugin;

      // Verify plugin structure
      expect(plugin).toBeDefined();
      expect(plugin.name).toBe('@elizaos/plugin-time-test');
      expect(plugin.actions).toBeDefined();
      expect(plugin.actions.length).toBeGreaterThan(0);
      expect(plugin.providers).toBeDefined();

      // Test the action
      const action = plugin.actions[0] as Action;
      expect(action.name).toBe('GET_CURRENT_TIME');

      // Create mock context
      const mockMessage: Memory = {
        id: '12345678-1234-1234-1234-123456789012' as `${string}-${string}-${string}-${string}-${string}`,
        content: { text: 'What time is it?' },
        roomId:
          '12345678-1234-1234-1234-123456789013' as `${string}-${string}-${string}-${string}-${string}`,
        agentId:
          '12345678-1234-1234-1234-123456789014' as `${string}-${string}-${string}-${string}-${string}`,
        entityId:
          '12345678-1234-1234-1234-123456789015' as `${string}-${string}-${string}-${string}-${string}`,
        createdAt: Date.now(),
      };

      const mockState = {} as any;
      const mockCallback = vi.fn();

      // Test validate
      const isValid = await action.validate(runtime, mockMessage, mockState);
      expect(isValid).toBe(true);

      // Test handler
      const result = await action.handler(runtime, mockMessage, mockState, {}, mockCallback);

      expect(result).toBeDefined();
      expect((result as any).text).toContain('Current time:');
      expect((result as any).success).toBe(true);
      expect(mockCallback).toHaveBeenCalled();

      // Test the provider
      const provider = plugin.providers![0] as Provider;
      expect(provider.name).toBe('TIME_PROVIDER');

      const providerResult = await provider.get(runtime, mockMessage, mockState);
      expect(providerResult).toBeDefined();
      expect(providerResult.text).toContain('timestamp');
      expect(providerResult.data).toHaveProperty('timestamp');

      console.log('✅ Plugin verification successful!');
    } catch (error) {
      console.error('Plugin verification failed:', error);
      throw error;
    }
  });

  it('should create a plugin that integrates with ElizaOS runtime', async () => {
    const apiKey = process.env.ANTHROPIC_API_KEY;

    if (!apiKey) {
      console.log('⚠️  Skipping: ANTHROPIC_API_KEY not set');
      return;
    }

    // Create a more complex plugin
    const mockAnthropicCreate = vi.fn().mockResolvedValueOnce({
      content: [
        {
          type: 'text',
          text: `\`\`\`typescript
// file: src/index.ts
import { Plugin, Service, IAgentRuntime, logger } from '@elizaos/core';
import { weatherAction } from './actions/weatherAction.js';
import { WeatherService } from './services/WeatherService.js';

export const weatherPlugin: Plugin = {
  name: '@elizaos/plugin-weather-test',
  description: 'Weather plugin with service',
  actions: [weatherAction],
  services: [WeatherService],
};

export default weatherPlugin;
\`\`\`

\`\`\`typescript
// file: src/services/WeatherService.ts
import { Service, IAgentRuntime, logger } from '@elizaos/core';

export class WeatherService extends Service {
  static serviceType = 'weather';
  
  constructor(runtime: IAgentRuntime) {
    super(runtime);
  }

  async start() {
    logger.info('Weather service started');
    return this;
  }

  async getWeather(location: string): Promise<any> {
    // Mock weather data
    return {
      location,
      temperature: Math.floor(Math.random() * 30) + 10,
      condition: ['sunny', 'cloudy', 'rainy'][Math.floor(Math.random() * 3)],
    };
  }
}
\`\`\`

\`\`\`typescript
// file: src/actions/weatherAction.ts
import { Action, IAgentRuntime, Memory, State, HandlerCallback, Content } from '@elizaos/core';
import { WeatherService } from '../services/WeatherService.js';

export const weatherAction: Action = {
  name: 'GET_WEATHER',
  description: 'Get weather for a location',
  
  validate: async (runtime: IAgentRuntime, message: Memory, state: State): Promise<boolean> => {
    const text = message.content.text?.toLowerCase() || '';
    return text.includes('weather');
  },
  
  handler: async (
    runtime: IAgentRuntime,
    message: Memory,
    state: State,
    options: any,
    callback: HandlerCallback
  ): Promise<any> => {
    const weatherService = runtime.services.get('weather') as WeatherService;
    
    if (!weatherService) {
      const errorContent: Content = {
        text: 'Weather service not available',
        success: false
      };
      if (callback) await callback(errorContent);
      return errorContent;
    }
    
    const location = options.location || 'New York';
    const weather = await weatherService.getWeather(location);
    
    const content: Content = {
      text: \`Weather in \${location}: \${weather.temperature}°C, \${weather.condition}\`,
      success: true,
      data: weather
    };
    
    if (callback) await callback(content);
    return content;
  },
  
  examples: []
};
\`\`\``,
        },
      ],
    });

    // Update the mock function
    (service as any).anthropic.messages.create = mockAnthropicCreate;

    const spec = {
      name: '@elizaos/plugin-weather-test',
      description: 'Weather plugin with service integration',
      actions: [
        {
          name: 'getWeather',
          description: 'Get weather information',
        },
      ],
      services: [
        {
          name: 'WeatherService',
          description: 'Weather data service',
        },
      ],
    };

    // Pass a dummy API key to satisfy the validation
    const jobId = await service.createPlugin(spec, undefined, { useTemplate: false });

    // Wait for completion
    let job = service.getJobStatus(jobId);
    while (job && job.status === 'running') {
      await new Promise((resolve) => setTimeout(resolve, 1000));
      job = service.getJobStatus(jobId);
    }

    expect(job!.status).toBe('completed');
    testPluginPath = job!.outputPath;

    // Build and verify
    const buildProcess = spawn('npm', ['run', 'build'], {
      cwd: testPluginPath,
      shell: true,
    });

    await new Promise((resolve, reject) => {
      buildProcess.on('close', (code) => {
        if (code === 0) resolve(undefined);
        else reject(new Error(`Build failed with code ${code}`));
      });
    });

    // Load and test the plugin with service
    const pluginModule = await import(path.join(testPluginPath, 'dist/index.js'));
    const plugin: Plugin = pluginModule.default || pluginModule.weatherPlugin;

    expect(plugin.services).toBeDefined();
    expect(plugin.services!.length).toBe(1);

    console.log('✅ Complex plugin with service verified!');
  });
});
