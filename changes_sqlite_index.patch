diff --git a/packages/adapter-sqlite/src/index.ts b/packages/adapter-sqlite/src/index.ts
index eec732e33..c20c32ff0 100644
--- a/packages/adapter-sqlite/src/index.ts
+++ b/packages/adapter-sqlite/src/index.ts
@@ -16,18 +16,38 @@ import { Database } from "better-sqlite3";
 import { v4 } from "uuid";
 import { load } from "./sqlite_vec.ts";
 import { sqliteTables } from "./sqliteTables.ts";
-interface RapportScore {
+
+interface Conversation {
     id: UUID;
-    userId: UUID;
+    rootTweetId?: string;
+    messageIds: string;  // JSON string of UUIDs
+    participantIds: string;  // JSON string of UUIDs
+    startedAt: Date;
+    lastMessageAt: Date;
+    context: string;
     agentId: UUID;
-    score: number;
-    lastUpdated: Date;
-    interactionCount: number;
+    status: 'ACTIVE' | 'CLOSED';  // Updated to match interface
 }
+
 export class SqliteDatabaseAdapter
     extends DatabaseAdapter<Database>
     implements IDatabaseCacheAdapter
 {
+    public db: Database;
+
+    constructor(db: Database) {
+        super();
+        this.db = db;
+        // Load SQLite vector extension functions
+        try {
+            load(db);
+            console.log("SQLite vector extension loaded successfully");
+        } catch (error) {
+            console.error("Error loading SQLite vector extension:", error);
+            throw error;
+        }
+    }
+
     async getRoom(roomId: UUID): Promise<UUID | null> {
         const sql = "SELECT id FROM rooms WHERE id = ?";
         const room = this.db.prepare(sql).get(roomId) as
@@ -64,6 +84,64 @@ export class SqliteDatabaseAdapter
             | undefined;
         return res?.userState ?? null;
     }
+    async getConversationMessages(conversationId: UUID): Promise<Memory[]> {
+        const conversation = await this.getConversation(conversationId);
+        if (!conversation) return [];
+
+        const messageIds = JSON.parse(conversation.messageIds);
+        const messages = await Promise.all(
+            messageIds.map(id => this.getMemoryById(id))
+        );
+
+        return messages
+            .filter((m): m is Memory => m !== null)
+            .map(memory => {
+                let timestamp: number;
+
+                if (typeof memory.createdAt === 'number') {
+                    timestamp = memory.createdAt;
+                } else if (typeof memory.createdAt === 'string') {
+                    timestamp = new Date(memory.createdAt).getTime();
+                } else if (memory.createdAt && typeof memory.createdAt === 'object') {
+                    timestamp = (memory.createdAt as Date).getTime();
+                } else {
+                    timestamp = Date.now();
+                }
+
+                return {
+                    ...memory,
+                    createdAt: timestamp
+                };
+            })
+            .sort((a, b) => a.createdAt - b.createdAt);
+    }
+
+    async getFormattedConversation(conversationId: UUID): Promise<string> {
+        const conversation = await this.getConversation(conversationId);
+        if (!conversation) return "";
+
+        const messages = await this.getConversationMessages(conversationId);
+
+        // Format each message showing only username
+        const formattedMessages = await Promise.all(messages.map(async msg => {
+            // First try to get username from message content
+            let username = msg.content.username;
+
+            // If no username in content, try to get it from accounts table
+            if (!username) {
+                const account = await this.getAccountById(msg.userId);
+                if (account?.username) {
+                    username = account.username;
+                }
+            }
+            console.log("username", username)
+            // Add @ prefix if we found a username
+            const displayName = username ? `@${username}` : `user_${msg.userId.substring(0, 8)}`;
+            return `${displayName}: ${msg.content.text}`;
+        }));
+
+        return formattedMessages.join('\n\n');
+    }
 
     async setParticipantUserState(
         roomId: UUID,
@@ -76,12 +154,6 @@ export class SqliteDatabaseAdapter
         stmt.run(state, roomId, userId);
     }
 
-    constructor(db: Database) {
-        super();
-        this.db = db;
-        load(db);
-    }
-
     async init() {
         this.db.exec(sqliteTables);
     }
@@ -156,19 +228,29 @@ export class SqliteDatabaseAdapter
         agentId: UUID;
         roomIds: UUID[];
         tableName: string;
+        limit?: number;
     }): Promise<Memory[]> {
         if (!params.tableName) {
             // default to messages
             params.tableName = "messages";
         }
+
         const placeholders = params.roomIds.map(() => "?").join(", ");
-        const sql = `SELECT * FROM memories WHERE type = ? AND agentId = ? AND roomId IN (${placeholders})`;
+        let sql = `SELECT * FROM memories WHERE type = ? AND agentId = ? AND roomId IN (${placeholders})`;
+
         const queryParams = [
             params.tableName,
             params.agentId,
             ...params.roomIds,
         ];
 
+        // Add ordering and limit
+        sql += ` ORDER BY createdAt DESC`;
+        if (params.limit) {
+            sql += ` LIMIT ?`;
+            queryParams.push(params.limit.toString());
+        }
+
         const stmt = this.db.prepare(sql);
         const rows = stmt.all(...queryParams) as (Memory & {
             content: string;
@@ -196,6 +278,33 @@ export class SqliteDatabaseAdapter
         return null;
     }
 
+    async getMemoriesByIds(
+        memoryIds: UUID[],
+        tableName?: string
+    ): Promise<Memory[]> {
+        if (memoryIds.length === 0) return [];
+        const queryParams: any[] = [];
+        const placeholders = memoryIds.map(() => "?").join(",");
+        let sql = `SELECT * FROM memories WHERE id IN (${placeholders})`;
+        queryParams.push(...memoryIds);
+
+        if (tableName) {
+            sql += ` AND type = ?`;
+            queryParams.push(tableName);
+        }
+
+        const memories = this.db.prepare(sql).all(...queryParams) as Memory[];
+
+        return memories.map((memory) => ({
+            ...memory,
+            createdAt:
+                typeof memory.createdAt === "string"
+                    ? Date.parse(memory.createdAt as string)
+                    : memory.createdAt,
+            content: JSON.parse(memory.content as unknown as string),
+        }));
+    }
+
     async createMemory(memory: Memory, tableName: string): Promise<void> {
         // Delete any existing memory with the same ID first
         // const deleteSql = `DELETE FROM memories WHERE id = ? AND type = ?`;
@@ -222,19 +331,27 @@ export class SqliteDatabaseAdapter
         const content = JSON.stringify(memory.content);
         const createdAt = memory.createdAt ?? Date.now();
 
+        let embeddingValue: Float32Array = new Float32Array(384);
+        // If embedding is not available, we just load an array with a length of 384
+        if (memory?.embedding && memory?.embedding?.length > 0) {
+            embeddingValue = new Float32Array(memory.embedding);
+        }
+
         // Insert the memory with the appropriate 'unique' value
         const sql = `INSERT OR REPLACE INTO memories (id, type, content, embedding, userId, roomId, agentId, \`unique\`, createdAt) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`;
-        this.db.prepare(sql).run(
-            memory.id ?? v4(),
-            tableName,
-            content,
-            new Float32Array(memory.embedding!), // Store as Float32Array
-            memory.userId,
-            memory.roomId,
-            memory.agentId,
-            isUnique ? 1 : 0,
-            createdAt
-        );
+        this.db
+            .prepare(sql)
+            .run(
+                memory.id ?? v4(),
+                tableName,
+                content,
+                embeddingValue,
+                memory.userId,
+                memory.roomId,
+                memory.agentId,
+                isUnique ? 1 : 0,
+                createdAt
+            );
     }
 
     async searchMemories(params: {
@@ -677,6 +794,39 @@ export class SqliteDatabaseAdapter
             .prepare(sql)
             .all(params.userId, params.userId) as Relationship[];
     }
+    async getUserRapport(userId: UUID, agentId: UUID): Promise<number> {
+        try {
+            const sql = "SELECT userRapport FROM accounts WHERE id = ?";
+            const account = this.db.prepare(sql).get(userId) as { userRapport: number } | undefined;
+            return account?.userRapport ?? 0;
+        } catch (error) {
+            console.error("Error getting user rapport:", error);
+            return 0;
+        }
+    }
+
+    async setUserRapport(userIdOrUsername: UUID | string, agentId: UUID, score: number): Promise<void> {
+        try {
+            let sql;
+            let params;
+
+            // Check if we're dealing with a username or userId
+            if (userIdOrUsername.includes('-')) {
+                // It's a UUID
+                sql = "UPDATE accounts SET userRapport = userRapport + ? WHERE id = ?";
+                params = [score, userIdOrUsername];
+            } else {
+                // It's a username
+                sql = "UPDATE accounts SET userRapport = userRapport + ? WHERE username = ?";
+                params = [score, userIdOrUsername.replace('@', '')];
+            }
+
+            elizaLogger.debug("Setting rapport for", userIdOrUsername, "score:", score);
+            this.db.prepare(sql).run(...params);
+        } catch (error) {
+            elizaLogger.error("Error setting user rapport:", error);
+        }
+    }
 
     async getCache(params: {
         key: string;
@@ -714,65 +864,104 @@ export class SqliteDatabaseAdapter
             return false;
         }
     }
-    async getUserRapport(userId: UUID, agentId: UUID): Promise<RapportScore | null> {
-        const sql = `
-            SELECT * FROM user_rapport
-            WHERE userId = ? AND agentId = ?
-        `;
 
-        const result = this.db.prepare(sql).get(userId, agentId) as RapportScore | undefined;
-        
-        if (!result) return null;
-        
+    async getConversation(conversationId: UUID): Promise<Conversation | null> {
+        const sql = "SELECT * FROM conversations WHERE id = ?";
+        const conversation = this.db.prepare(sql).get(conversationId) as (Omit<Conversation, 'status'> & { status?: string }) | undefined;
+
+        if (!conversation) return null;
+
         return {
-            id: result.id,
-            userId: result.userId,
-            agentId: result.agentId,
-            score: result.score,
-            lastUpdated: new Date(result.lastUpdated),
-            interactionCount: result.interactionCount
+            ...conversation,
+            startedAt: new Date(conversation.startedAt),
+            lastMessageAt: new Date(conversation.lastMessageAt),
+            status: (conversation.status || 'ACTIVE') as 'ACTIVE' | 'CLOSED'
         };
     }
-    async updateUserRapport(params: {
-        userId: UUID;
-        agentId: UUID;
-        score: number;
-    }): Promise<void> {
-        const existingRapport = await this.getUserRapport(params.userId, params.agentId);
-
-        if (!existingRapport) {
-            // Insert new rapport
-            const sql = `
-                INSERT INTO user_rapport (id, userId, agentId, score, interactionCount)
-                VALUES (?, ?, ?, ?, 1)
-            `;
-            this.db.prepare(sql).run(v4(), params.userId, params.agentId, params.score);
-        } else {
-            // Update existing rapport
-            const sql = `
-                UPDATE user_rapport
-                SET score = ?,
-                    interactionCount = interactionCount + 1,
-                    lastUpdated = CURRENT_TIMESTAMP
-                WHERE userId = ? AND agentId = ?
-            `;
-            this.db.prepare(sql).run(params.score, params.userId, params.agentId);
-        }
-    }
-
-    async getAllUserRapports(userId: UUID): Promise<RapportScore[]> {
+
+    async storeConversation(conversation: Conversation): Promise<void> {
         const sql = `
-            SELECT * FROM user_rapport
-            WHERE userId = ?
-            ORDER BY score DESC
+            INSERT INTO conversations (
+                id, rootTweetId, messageIds, participantIds,
+                startedAt, lastMessageAt, context, agentId, status
+            )
+            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
         `;
 
-        const results = this.db.prepare(sql).all(userId) as RapportScore[];
-        
-        return results.map(result => ({
-            ...result,
-            lastUpdated: new Date(result.lastUpdated)
+        this.db.prepare(sql).run(
+            conversation.id,
+            conversation.rootTweetId || '',  // Ensure string
+            conversation.messageIds,
+            conversation.participantIds,
+            conversation.startedAt.getTime(),
+            conversation.lastMessageAt.getTime(),
+            conversation.context,
+            conversation.agentId,
+            conversation.status || 'ACTIVE'  // Ensure status is set
+        );
+    }
+
+    async updateConversation(conversation: Partial<Conversation> & { id: UUID }): Promise<void> {
+        const updates: string[] = [];
+        const values: any[] = [];
+
+        if (conversation.messageIds !== undefined) {
+            const existingConversation = await this.getConversation(conversation.id);
+            if (existingConversation) {
+                const existingIds = JSON.parse(existingConversation.messageIds);
+                const allNewIds = JSON.parse(conversation.messageIds);
+                const lastNewId = allNewIds[allNewIds.length - 1]; // Get the last message ID
+                elizaLogger.debug("added new message ", lastNewId);
+
+                if (existingIds.includes(lastNewId)) {
+                    elizaLogger.debug("message already exists");
+                    return; // Exit early if message already exists
+                }
+            }
+            updates.push('messageIds = ?');
+            values.push(conversation.messageIds);
+        }
+        if (conversation.participantIds !== undefined) {
+            updates.push('participantIds = ?');
+            values.push(conversation.participantIds);
+        }
+        if (conversation.lastMessageAt !== undefined) {
+            updates.push('lastMessageAt = ?');
+            values.push(conversation.lastMessageAt.getTime());
+        }
+        if (conversation.context !== undefined) {
+            updates.push('context = ?');
+            values.push(conversation.context);
+        }
+        if (conversation.status !== undefined) {
+            updates.push('status = ?');
+            values.push(conversation.status);
+        }
+
+        if (updates.length === 0) return;
+
+        const sql = `UPDATE conversations SET ${updates.join(', ')} WHERE id = ?`;
+        values.push(conversation.id);
+
+        this.db.prepare(sql).run(...values);
+    }
+
+    async getConversationsByStatus(status: 'ACTIVE' | 'CLOSED', limit?: number): Promise<Conversation[]> {
+        let sql = "SELECT * FROM conversations WHERE status = ?";
+        const params: any[] = [status];
+
+        if (typeof limit === 'number') {
+            sql += " LIMIT ?";
+            params.push(limit);
+        }
+
+        const conversations = this.db.prepare(sql).all(...params) as (Omit<Conversation, 'status'> & { status?: string })[];
+
+        return conversations.map(conversation => ({
+            ...conversation,
+            startedAt: new Date(conversation.startedAt),
+            lastMessageAt: new Date(conversation.lastMessageAt),
+            status: (conversation.status || 'ACTIVE') as 'ACTIVE' | 'CLOSED'
         }));
     }
 }
-
