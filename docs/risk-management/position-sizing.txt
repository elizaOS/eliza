# Position Sizing

## Introduction

Position sizing is the most critical yet underestimated skill in DeFi portfolio management—the difference between sustainable wealth creation and spectacular blow-ups. While traders obsess over finding the perfect yield farming opportunity, professionals focus on the precise question: "How much capital should I allocate?" Position sizing transforms gambling into systematic investing, turning the wild west of DeFi into a calculated game of probabilities. For Levva's strategies, proper position sizing determines whether Diversified DeFi Yield approaches achieve their target risk-adjusted returns and whether Custom strategies survive the inevitable volatility storms that define crypto markets.

## Key Concepts, Ideas, and Formulas

### Kelly Criterion - The Mathematical Foundation

**Core Formula:**
```
Kelly % = (bp - q) / b
```
Where:
- `b` = odds (ratio of win to loss)
- `p` = probability of winning  
- `q` = probability of losing (1-p)

**DeFi Adaptation:**
```
Kelly % = (Win_Probability × Average_Return - Loss_Probability × Average_Loss) / Average_Return
```

**Practical Implementation:**
```python
def calculate_kelly_position(win_rate, avg_win, avg_loss):
    p = win_rate
    q = 1 - win_rate
    b = avg_win / avg_loss
    
    kelly_fraction = (b * p - q) / b
    return max(0, min(kelly_fraction, 0.25))  # Cap at 25% for safety
```

### Volatility-Based Position Sizing

**Target Volatility Framework:**
```
Position_Size = Target_Volatility / Asset_Volatility × Base_Position
```

**Risk Parity Allocation:**
```
Weight_i = (1/Volatility_i) / Σ(1/Volatility_j)
```

**Advanced Vol Targeting:**
```python
def dynamic_position_size(target_vol, realized_vol, lookback_period=30):
    vol_ratio = target_vol / realized_vol
    # Apply smoothing to prevent excessive turnover
    smoothed_ratio = 0.7 * vol_ratio + 0.3 * previous_ratio
    return min(max(smoothed_ratio, 0.5), 2.0)  # Constrain between 50%-200%
```

### Capital Allocation Models

**Fixed Percentage Model:**
```
Position_Size = Portfolio_Value × Fixed_Percentage
```

**Risk-Adjusted Allocation:**
```
Position_Size = Available_Capital × (Expected_Return / Max_Drawdown) × Risk_Tolerance
```

**Modified Kelly with Leverage:**
```
Leveraged_Kelly = Kelly_Fraction × (1 + Leverage_Ratio) - Leverage_Ratio
```

## Examples and Applications

### Conservative Diversified DeFi Yield Allocation

**Portfolio**: $100,000 USDC
**Target Volatility**: 8% annually
**Strategy Mix**: Stablecoin lending + Liquid staking

**Allocation Calculation:**
```python
strategies = {
    'aave_usdc': {'expected_return': 0.04, 'volatility': 0.02, 'max_allocation': 0.4},
    'lido_steth': {'expected_return': 0.06, 'volatility': 0.15, 'max_allocation': 0.3},
    'curve_3pool': {'expected_return': 0.08, 'volatility': 0.05, 'max_allocation': 0.3}
}

def calculate_risk_parity_weights(strategies):
    inv_vols = {k: 1/v['volatility'] for k, v in strategies.items()}
    total_inv_vol = sum(inv_vols.values())
    
    weights = {}
    for strategy, inv_vol in inv_vols.items():
        risk_parity_weight = inv_vol / total_inv_vol
        max_weight = strategies[strategy]['max_allocation']
        weights[strategy] = min(risk_parity_weight, max_weight)
    
    return weights
```

**Result:**
- Aave USDC: 40% ($40,000) - Max allocation limit
- Lido stETH: 15% ($15,000) - Vol-adjusted
- Curve 3pool: 30% ($30,000) - Balanced exposure
- Cash Buffer: 15% ($15,000) - Emergency reserves

### Aggressive Custom Strategy Sizing

**Scenario**: Leveraged PT-sUSDe farming
**Available Capital**: $50,000
**Expected APY**: 45%
**Estimated Volatility**: 35%
**Win Rate**: 65% (based on backtesting)

**Kelly Calculation:**
```python
# Historical performance analysis
win_rate = 0.65
avg_monthly_return = 0.45 / 12  # 3.75% monthly
avg_monthly_loss = -0.15  # -15% during bad months
avg_loss_rate = 1 - win_rate

kelly_fraction = (win_rate * avg_monthly_return - avg_loss_rate * abs(avg_monthly_loss)) / avg_monthly_return
print(f"Kelly Fraction: {kelly_fraction:.2%}")  # ~42%

# Apply conservative modifier for DeFi volatility
conservative_kelly = kelly_fraction * 0.5  # Use 50% of Kelly
position_size = 50000 * conservative_kelly
print(f"Recommended Position: ${position_size:,.0f}")  # ~$10,500
```

### Multi-Strategy Portfolio Optimization

**Capital**: $250,000
**Strategies**: 5 different yield farming approaches
**Objective**: Maximize Sharpe ratio while constraining max drawdown

**Implementation:**
```python
import numpy as np
from scipy.optimize import minimize

def portfolio_optimization(expected_returns, covariance_matrix, risk_aversion=3):
    n_assets = len(expected_returns)
    
    # Objective function: maximize utility (return - risk penalty)
    def objective(weights):
        portfolio_return = np.dot(weights, expected_returns)
        portfolio_variance = np.dot(weights.T, np.dot(covariance_matrix, weights))
        utility = portfolio_return - 0.5 * risk_aversion * portfolio_variance
        return -utility  # Minimize negative utility
    
    # Constraints
    constraints = [
        {'type': 'eq', 'fun': lambda x: np.sum(x) - 1.0},  # Weights sum to 1
        {'type': 'ineq', 'fun': lambda x: 0.4 - np.max(x)}  # Max 40% per strategy
    ]
    
    bounds = [(0, 0.4) for _ in range(n_assets)]  # 0-40% per strategy
    
    result = minimize(objective, x0=np.ones(n_assets)/n_assets, 
                     bounds=bounds, constraints=constraints)
    
    return result.x

# Example data
expected_returns = np.array([0.06, 0.12, 0.25, 0.35, 0.15])  # Annual returns
volatilities = np.array([0.05, 0.15, 0.30, 0.50, 0.20])  # Annual volatilities
correlations = np.array([  # Correlation matrix
    [1.00, 0.30, 0.10, 0.05, 0.20],
    [0.30, 1.00, 0.40, 0.20, 0.35],
    [0.10, 0.40, 1.00, 0.60, 0.25],
    [0.05, 0.20, 0.60, 1.00, 0.15],
    [0.20, 0.35, 0.25, 0.15, 1.00]
])

covariance_matrix = np.outer(volatilities, volatilities) * correlations
optimal_weights = portfolio_optimization(expected_returns, covariance_matrix)
```

### Dynamic Position Sizing with Market Regimes

**Market Regime Detection:**
```python
def detect_market_regime(returns, volatility_threshold=0.20):
    rolling_vol = returns.rolling(30).std() * np.sqrt(365)
    
    if rolling_vol.iloc[-1] < volatility_threshold:
        return "low_volatility"
    elif rolling_vol.iloc[-1] < volatility_threshold * 2:
        return "medium_volatility"  
    else:
        return "high_volatility"

def regime_adjusted_sizing(base_allocation, market_regime):
    regime_multipliers = {
        "low_volatility": 1.2,    # Increase allocation 20%
        "medium_volatility": 1.0,  # Maintain allocation
        "high_volatility": 0.6     # Reduce allocation 40%
    }
    
    return base_allocation * regime_multipliers[market_regime]
```

## Risks and Mitigations

### Over-Sizing Risks

**Concentration Risk:**
- Single strategy failure can destroy portfolio
- Correlation spikes during market stress
- Liquidity constraints during exit needs

**Leverage Risk:**
- Amplified losses during drawdowns
- Liquidation cascades in volatile markets
- Margin call requirements exceed available capital

**Behavioral Risk:**
- Emotional decision-making during losses
- FOMO-driven position sizing increases
- Loss aversion preventing necessary exits

### Under-Sizing Risks

**Opportunity Cost:**
- Missing significant returns due to excessive conservatism
- Inflation protection inadequate for small positions
- Fixed costs overwhelming small position returns

**Capital Inefficiency:**
- Idle capital earning minimal returns
- Transaction costs as percentage of position too high
- Diversification benefits diminished

### Risk Mitigation Framework

**Position Size Limits:**
```python
class PositionSizeLimits:
    def __init__(self, risk_category):
        self.limits = {
            'ultra_safe': {'max_single': 0.25, 'max_correlated': 0.40},
            'safe': {'max_single': 0.30, 'max_correlated': 0.50},
            'brave': {'max_single': 0.35, 'max_correlated': 0.60},
            'custom': {'max_single': 0.50, 'max_correlated': 0.80}
        }[risk_category]
    
    def validate_allocation(self, proposed_weights, correlations):
        # Check single position limits
        if max(proposed_weights) > self.limits['max_single']:
            return False, "Single position too large"
            
        # Check correlated exposure
        for i, weight_i in enumerate(proposed_weights):
            correlated_exposure = weight_i
            for j, weight_j in enumerate(proposed_weights):
                if i != j and correlations[i][j] > 0.7:
                    correlated_exposure += weight_j
            
            if correlated_exposure > self.limits['max_correlated']:
                return False, "Correlated exposure too high"
        
        return True, "Allocation valid"
```

**Dynamic Rebalancing:**
```python
def rebalancing_trigger(current_weights, target_weights, threshold=0.05):
    weight_deviations = abs(current_weights - target_weights)
    max_deviation = max(weight_deviations)
    
    return max_deviation > threshold
```

## Unconventional Wisdom and Insights

### The Position Size Paradox

**Conventional Wisdom**: Larger positions in high-conviction strategies
**Reality**: Optimal position sizes are often smaller than intuition suggests

**Mathematical Proof**: Due to volatility's non-linear impact on compound returns:
```
Geometric_Return = Arithmetic_Return - (Variance / 2)
```

**Insight**: Even with 70% win rate and 2:1 risk/reward, optimal Kelly position is only ~40% of capital.

### The Correlation Clustering Effect

**Discovery**: DeFi protocol correlations increase dramatically during stress periods:

```python
def stress_correlation_adjustment(normal_correlation, stress_multiplier=2.5):
    # Correlations approach 1.0 during market stress
    stressed_correlation = min(normal_correlation * stress_multiplier, 0.95)
    return stressed_correlation
```

**Strategy Implication**: Size positions assuming stress-period correlations, not normal-period correlations.

### The Gas Cost Threshold

**Insight**: Transaction costs create a minimum viable position size:

```python
def minimum_position_size(gas_cost_usd, target_profit_margin=0.05, strategy_apy=0.20):
    # Position must be large enough that gas costs don't erode returns
    annual_gas_cost = gas_cost_usd * 12  # Monthly rebalancing
    min_position = annual_gas_cost / (strategy_apy * target_profit_margin)
    return min_position
```

**Example**: $50 gas cost → $15,000 minimum position for 20% APY strategy

### The Liquidity-Size Relationship

**Non-Linear Discovery**: Position size effectiveness follows a power law:

```
Effective_Position_Size = Nominal_Position_Size × (Available_Liquidity / Nominal_Position_Size)^0.3
```

**Strategic Application**: Don't allocate more than 10% of available protocol liquidity to maintain execution efficiency.

### The Time Horizon Position Scaling

**Insight**: Optimal position sizes change with investment time horizon:

```python
def time_horizon_adjustment(base_kelly, time_horizon_months):
    # Longer horizons allow larger positions due to volatility decay
    time_adjustment = min(sqrt(time_horizon_months / 12), 1.5)
    return base_kelly * time_adjustment
```

### The Compounding Frequency Optimization

**Discovery**: More frequent rebalancing doesn't always improve returns:

```python
def optimal_rebalancing_frequency(volatility, transaction_cost):
    # Balance between maintaining target allocation and minimizing costs
    optimal_frequency_days = sqrt(transaction_cost / (volatility ** 2 * 252))
    return max(7, min(optimal_frequency_days, 90))  # Between weekly and quarterly
```

## Further Links and Knowledge Base

### Academic Research and Theory

**Foundational Papers:**
- **"A New Interpretation of Information Rate"** (Kelly, 1956) - Original Kelly criterion
- **"Portfolio Selection"** (Markowitz, 1952) - Modern portfolio theory foundation
- **"The Leverage Space Trading Model"** (Vince, 1992) - Fixed fractional trading

**DeFi-Specific Research:**
- **"Optimal Portfolio Management in DeFi"** (Chen et al., 2022)
- **"Risk-Return Characteristics of Cryptocurrency Investments"** (Liu & Tsyvinski, 2021)
- **"The Economics of DeFi Liquidity Mining"** (Gudgeon et al., 2021)

### Practical Implementation Tools

**Python Libraries:**
```python
# Essential libraries for position sizing
import numpy as np
import pandas as pd
from scipy.optimize import minimize
from sklearn.covariance import LedoitWolf

# Portfolio optimization
import cvxpy as cp  # Convex optimization
import pypfopt  # Portfolio optimization

# Risk modeling
import arch  # GARCH volatility modeling
import statsmodels.api as sm  # Statistical analysis
```

**Risk Management Platforms:**
- **QuantConnect**: Algorithmic trading with Kelly optimization
- **Zipline**: Open-source backtesting with position sizing
- **Backtrader**: Python backtesting framework with portfolio allocation

### DeFi-Specific Tools

**Portfolio Analytics:**
- **DefiLlama**: TVL and protocol risk assessment
- **Zapper**: Portfolio tracking and rebalancing tools
- **Zerion**: Cross-protocol position monitoring

**Risk Assessment:**
- **Gauntlet**: Protocol parameter optimization and risk modeling
- **DeFiSafety**: Protocol safety scoring for allocation decisions
- **Nexus Mutual**: Insurance pricing as risk proxy

### Levva Framework Integration

**Strategy-Specific Position Sizing:**

```python
class LevvaPositionSizer:
    def __init__(self, strategy_type, risk_category):
        self.strategy_type = strategy_type
        self.risk_category = risk_category
        self.max_allocation = self._get_max_allocation()
    
    def _get_max_allocation(self):
        allocations = {
            ('diversified_defi_yield', 'ultra_safe'): 0.25,
            ('diversified_defi_yield', 'safe'): 0.30,
            ('diversified_defi_yield', 'brave'): 0.35,
            ('custom', 'any'): 0.50
        }
        
        key = (self.strategy_type, self.risk_category)
        if key in allocations:
            return allocations[key]
        else:
            return allocations[('custom', 'any')]
    
    def calculate_position_size(self, expected_return, volatility, portfolio_value):
        # Kelly-based calculation with safety constraints
        kelly_fraction = self._calculate_kelly(expected_return, volatility)
        conservative_kelly = kelly_fraction * 0.5  # 50% of Kelly for safety
        
        max_position = portfolio_value * self.max_allocation
        kelly_position = portfolio_value * conservative_kelly
        
        return min(max_position, kelly_position)
```

**Risk-Based Allocation Matrix:**

| Risk Category | Max Single Position | Max Correlated Group | Rebalancing Frequency |
|---------------|-------------------|---------------------|---------------------|
| Ultra-Safe | 25% | 40% | Monthly |
| Safe | 30% | 50% | Bi-weekly |
| Brave | 35% | 60% | Weekly |
| Custom | 50% | 80% | Daily |

### Related Knowledge Base Files
- `correlation-analysis.md` - Understanding asset correlation for position sizing
- `portfolio-theory.md` - Modern portfolio theory applications in DeFi
- `liquidation-mechanics.md` - Position sizing considering liquidation risk
- `yield-farming-basics.md` - Integrating position sizing with yield strategies