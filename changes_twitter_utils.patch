diff --git a/packages/client-twitter/src/utils.ts b/packages/client-twitter/src/utils.ts
index 860719ab8..8c8227cca 100644
--- a/packages/client-twitter/src/utils.ts
+++ b/packages/client-twitter/src/utils.ts
@@ -1,10 +1,10 @@
 import { Tweet } from "agent-twitter-client";
-import { getEmbeddingZeroVector } from "@elizaos/core";
+import { getEmbeddingZeroVector, composeContext, elizaLogger,  generateText,ModelClass
+} from "@elizaos/core";
 import type { Content, Memory, UUID, IAgentRuntime } from "@elizaos/core";
 
 import { stringToUuid } from "@elizaos/core";
 import { ClientBase } from "./base";
-import { elizaLogger } from "@elizaos/core";
 import { DEFAULT_MAX_TWEET_LENGTH } from "./environment";
 import { Media } from "@elizaos/core";
 import fs from "fs";
@@ -32,15 +32,19 @@ export const isValidTweet = (tweet: Tweet): boolean => {
 };
 
 export async function buildConversationThread(
+    
     tweet: Tweet,
     client: ClientBase,
     maxReplies: number = 10
 ): Promise<Tweet[]> {
     const thread: Tweet[] = [];
     const visited: Set<string> = new Set();
-console.log("building THREAD HAHAHAHAH")
+    const conversationId = stringToUuid(tweet.conversationId + "-" + client.runtime.agentId);
+    const existingConversation = await client.runtime.databaseAdapter.getConversation(conversationId);
+
     async function processThread(currentTweet: Tweet, depth: number = 0) {
-        elizaLogger.debug("Processing tweet:", {
+        elizaLogger.debug("Processing tweet:", {
             id: currentTweet.id,
             inReplyToStatusId: currentTweet.inReplyToStatusId,
             depth: depth,

 
     await processThread(tweet, 0);
 
-    elizaLogger.debug("Final thread built:", {
+    // After thread is built, store conversation
+    const messageIds = thread.map(t =>
+        stringToUuid(t.id + "-" + client.runtime.agentId)
+    );
+
+    const participantIds = [...new Set(thread.map(t =>
+        t.userId === client.profile.id
+            ? client.runtime.agentId
+            : stringToUuid(t.userId)
+    ))];
+
+    // Format conversation for analysis
+    const formattedConversation = thread.map(tweet => `@${tweet.username}: ${tweet.text}`)
+        .join("\n");
+
+    elizaLogger.debug("Conversation thread built:", {
+        messageCount: thread.length,
+        participants: thread.map(t => t.username).filter((v, i, a) => a.indexOf(v) === i),
+        messageIds: messageIds,
+        conversationId: conversationId
+    });
+    if (existingConversation) {
+        // Parse existing JSON arrays
+        elizaLogger.debug("Updating existing conversation", {
+            id: conversationId,
+            newMessageCount: messageIds.length,
+            
+        });
+        const existingMessageIds = JSON.parse(existingConversation.messageIds);
+        const existingParticipantIds = JSON.parse(existingConversation.participantIds);
+        await client.runtime.databaseAdapter.updateConversation({
+            id: conversationId,
+            messageIds: JSON.stringify([...new Set([...existingMessageIds, ...messageIds])]),
+            participantIds: JSON.stringify([...new Set([...existingParticipantIds, ...participantIds])]),
+            lastMessageAt: new Date(Math.max(
+                ...thread.map(t => t.timestamp * 1000),
+                existingConversation.lastMessageAt.getTime()
+            )),
+            context: formattedConversation,
+            status: 'ACTIVE'
+        });
+    } else {
+        elizaLogger.debug("Creating new conversation", {
+            id: conversationId,
+            messageCount: messageIds.length,
+            participantCount: participantIds.length
+        });
+        await client.runtime.databaseAdapter.storeConversation({
+            id: conversationId,
+            rootTweetId: thread[0].id,
+            messageIds: JSON.stringify(messageIds),
+            participantIds: JSON.stringify(participantIds),
+            startedAt: new Date(thread[0].timestamp * 1000),
+            lastMessageAt: new Date(thread[thread.length - 1].timestamp * 1000),
+            context: formattedConversation,
+            agentId: client.runtime.agentId
+        });
+    }
+elizaLogger.debug("Final thread details:", {
         totalTweets: thread.length,
-        tweetIds: thread.map((t) => ({
+        tweetDetails: thread.map(t => ({
             id: t.id,
-            text: t.text?.slice(0, 50),
-        })),
+            author: t.username,
+            text: t.text?.slice(0, 50) + "..."
+        }))
     });
-
+    const conversationMessagess = await client.runtime.databaseAdapter.getConversationMessages(conversationId)
+    elizaLogger.debug ("conversation messages", conversationMessagess)
    return thread;
 }
 
@@ -369,49 +433,59 @@ export async function analyzeConversation(
     conversationId: UUID,
     runtime: IAgentRuntime
 ): Promise<void> {
+    
     const conversation = await runtime.databaseAdapter.getConversation(conversationId);
+    elizaLogger.debug("analyze conversation", conversation)
+    if (!conversation) {
+        elizaLogger.error("No conversation found for analysis", conversationId);
+        return;
+    }
 
     // Get all messages in order
-    const messages = await Promise.all(
-        JSON.parse(conversation.messageIds).map(id =>
-            runtime.messageManager.getMemoryById(id)
-        )
-    );
-
-    // Group messages by user
-    const userMessages = new Map<string, string[]>();
-    for (const message of messages) {
-        if (message.userId === runtime.agentId) continue; // Skip agent's messages
-
-        const username = message.content.username || message.userId;
-        if (!userMessages.has(username)) {
-            userMessages.set(username, []);
-        }
-        userMessages.get(username)?.push(message.content.text);
+    const messages = await runtime.databaseAdapter.getConversationMessages(conversationId);
+    if (messages.length === 0) {
+        elizaLogger.error("No messages found in conversation for analysis", conversationId);
+        return;
     }
+// Get the last message to use for state building
+    const lastMessage = messages[messages.length - 1];
+    // Build state with conversation context
+    const state = await runtime.composeState(lastMessage, {
+        conversationId: conversationId,
+        twitterUserName: runtime.getSetting("TWITTER_USERNAME")
+    });
 
-    // Format conversation for per-user analysis
-    const prompt = `Analyze each user's messages in this conversation and provide a sentiment score from -1.0 (very negative) to 1.0 (very positive).
-Consider factors like: politeness, engagement, friendliness, and cooperation.
-
-Context: ${conversation.context}
-
-${Array.from(userMessages.entries()).map(([username, msgs]) =>
-    `Messages from @${username}:\n${msgs.join('\n')}`
-).join('\n\n')}
 
-Return ONLY a JSON object with usernames as keys and scores as values. Example format:
-{
-    "@user1": 0.8,
-    "@user2": -0.3
-}`;
+    // Format conversation for per-user analysis
+    const analysisTemplate = ` 
+    #Conversation:
+    {{recentUserConversations}}
+
+    #Instructions:
+    Evaluate the messages the other users sent to you in this conversation. 
+    Rate each users messages sent to you as a whole using these metrics: [-5] very bad, [0] neutral, [5] very good. 
+    Evaluates these messages as the character {{agentName}} (@{{twitterUserName}}):with the context of the whole conversation. 
+    If you aren't sure if the message was directed to you, or you're missing context to give a good answer, give the score [0] neutral. 
+
+    Return ONLY a JSON object with usernames as keys and scores as values. Example format:
+    {
+        "@user1": 0.8,
+        "@user2": -0.3
+    }`;
+    const context = composeContext({
+        state,
+        template: analysisTemplate
+    });
+    console.log("context", context)
 
-    const analysis = await runtime.generateText({
-        prompt,
-        temperature: 0.7,
-        maxTokens: 5000
+    const analysis = await generateText({
+        runtime,
+        context,
+        modelClass: ModelClass.LARGE,
     });
 
+
 
     try {
@@ -420,20 +494,16 @@ Return ONLY a JSON object with usernames as keys and scores as values. Example f
         // Update conversation with analysis
         await runtime.databaseAdapter.updateConversation({
             id: conversationId,
-            analysis,
             status: 'CLOSED'
         });
 
         // Update user rapport based on sentiment scores
         for (const [username, score] of Object.entries(sentimentScores)) {
-            const userId = messages.find(m => m.content.username === username.replace('@', ''))?.userId;
-            if (userId) {
-                await runtime.databaseAdapter.updateUserRapport({
-                    userId,
-                    agentId: runtime.agentId,
-                    sentimentScore: score as number
-                });
-            }
+            await runtime.databaseAdapter.setUserRapport(
+                username,
+                runtime.agentId,
+                score as number
+            );
         }
     } catch (error) {
         elizaLogger.error("Error parsing sentiment analysis:", error);
@@ -450,7 +520,7 @@ export async function isConversationDone(
 
     const timeInactive = now.getTime() - lastMessageTime.getTime();
     if (timeInactive > 45 * 60 * 1000) {
-        elizaLogger.debug("Conversation inactive for 45 minutes, marking as done");
+       
         return true;
     }
 
